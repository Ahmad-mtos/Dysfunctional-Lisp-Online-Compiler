{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Description","title":"Description"},{"location":"#description","text":"","title":"Description"},{"location":"predefined_functions/","text":"predefined funcs","title":"Predefined Functions"},{"location":"predefined_functions/#predefined-funcs","text":"","title":"predefined funcs"},{"location":"special_forms/","text":"Special Forms Special Forms are lists that have special meanings. They start with a keyword that depicts the structure of the list and sets the behavior of it. prog (prog Params Body) Defenition This special form acts as an entry point to your program, it's like the 'main' function in many programming langugages. The Params parameter is a list of atoms. This parameter in the prog represents the input that's going to be taken from the user. The Body parameter of the form is considered as the body of the function, containing a list of elements, which represent the sequence of statements that are going to be evaluated. The prog form should always be included in any program, and it should always be the last element in it. Returns: The evaluation of the last statement inside its body, or the value returned from a 'return' form. Examples (prog (a b) (plus a b) ) this is a program that asks for 2 inputs, a and b , then returns their sum using the predefined function plus . (prog (a b) (minus a b) (plus a b) ) This code behaves the same as the previous one, since the last statment is the plus function. func ( func Atom Params Body ) Defenition This special form introduces a new user-defined function. The Atom parameter becomes the name of the function. The Params paremeter should contain a number of atoms that represent the function parameters. The Body parameter of the form is considered as the body of the function, containing a list of elements, which represent the sequence of statements that are going to be evaluated. Returns: The evaluation of the last statement inside its body, or the value returned from a 'return' form. Examples ( fun c sum 3 (a b c) (plus (plus a b) c) ) (prog () (sum 3 1 2 3 ) ) returns: 6 In this code we can see how we first define a new function called sum3 that takes 3 parameters, and returns the sum of them, then we call that function inside the prog form. Notice how the parameters are spread and not in a list when calling the sum3 function. quote (quo te Lis t ) or `List Defenition Any list is supposed to be a special form or starts with a predicate or user-defined function, expect if it was quoted, then it can contain other kinds of data. The main purpose of the quote form is to be able to create lists of numbers or other data, which can be manipulated using the lists predefined functions . To evaluate a quoted list, we can simply use the special form eval . The contents of the quoted list should fall under the main rule of lists. Returns: its argument without evaluating it. The meaning of the function is to prevent evaluating its argument. Examples (prog () (head '( 1 2 3 )) ) Returns: 1 (prog () ( ta il (quo te ( 1 2 3 ))) ) Returns: '(2 3) (or in other words, (quote (2 3))) setq (setq Atom Element) Defenition This special form assigns a new value to a variable, or defines the variable if it hasn't been defined before. The Atom parameter becomes the name of the variable. The Element paremeter gets evaluated, and the value it returns is assigned to the variable. Returns: null Examples (prog () (se t q x 5 ) (se t q x (plus 10 5 )) ) In this code first we define the variable x with the value 5, then we assign it a new value which is (plus 10 5) , which gets evaluated first and then assigned to x , which will finally hold the value of 15. cond (co n d Eleme nt Eleme nt [ Eleme nt ] ) Defenition This special form represents the conditional statement in Dysfunctional Lisp. The first Element parameter represents the condition statement. After evaluation it should hold a boolean value. The second Element parameter which is going to be evaluated in case the condition statement returned true . The third Element parameter is an optional parameter which is going to be evaluated in case the condition statement returned false . Returns: The evaluation of the second element if the condition was true, or the evaluation of the third element if the condition was false, or null in the absence of the third element. Examples (prog ( fla g a b) (co n d (grea ter fla g 5 ) (plus a b) (mi nus a b)) ) This code requires 3 inputs, if the first input was greater than 5, then it returns a + b , otherwise it returns a - b . while (while Eleme nt Body) Defenition This is the only form capable of looping (aside from recursion) in Dysfunctional Lisp. The Element parameter represents the condition in which the while form will keep looping as long as its evaluation is true . The Body parameter represents the body of the while form, which is a sequence of elements that are going to be evaluated in each repetetion. Returns: null Examples (prog () (se t q i 1 ) (se t q sum 0 ) (while (lesseq i 10 ) (se t q sum (plus sum i)) (se t q i (plus i 1 )) ) (re turn sum) ) Returns: 55 This is a simple code where we sum the numbers from 1 to 10. lambda (lambda Params Body) Defenition This special form represents a lambda function, at current stage of Dysfunctional Lisp, lambda functions are only used as callback functions, as we will see in the examples. The Params parameter represents the parameters of the lambda function. The Body parameter is considered as the body of the lambda function, containing a list of elements, which represent the sequence of statements that are going to be evaluated. Returns: The evaluation of the last statement inside its body, or the value returned from a 'return' form. Examples ( fun c map (ls t f ) (co n d (isemp t y ls t ) (re turn '())) (co ns ( f (head ls t )) (map ( ta il ls t ) f )) ) (prog () (se t q ls t '( 1 2 3 4 )) (map ls t (lambda (a) ( t imes a a))) ) Returns: '(1 4 9 16) return (re turn Eleme nt ) Defenition This special form makes sense within a form that defines a local context ( func , lambda or prog ). It evaluates its argument and interrupts the execution of the nearest enclosing form with the context. The Element parameter gets evaluated and returned. Returns: The Evaluation of its argument Examples (prog () (re turn 5 ) 10 ) Returns: 5 break (break) Defenition The special form makes sense within a while form. It unconditionally interrupts the execution of the nearest while form. Returns: null Examples (prog () (se t q i 0 ) (while true (co n d (grea tere q i 10 ) (break)) (se t q i (plus i 1 )) ) (re turn i) ) Returns: 10","title":"Special Forms"},{"location":"special_forms/#special-forms","text":"Special Forms are lists that have special meanings. They start with a keyword that depicts the structure of the list and sets the behavior of it.","title":"Special Forms"},{"location":"special_forms/#prog","text":"(prog Params Body)","title":"prog"},{"location":"special_forms/#defenition","text":"This special form acts as an entry point to your program, it's like the 'main' function in many programming langugages. The Params parameter is a list of atoms. This parameter in the prog represents the input that's going to be taken from the user. The Body parameter of the form is considered as the body of the function, containing a list of elements, which represent the sequence of statements that are going to be evaluated. The prog form should always be included in any program, and it should always be the last element in it. Returns: The evaluation of the last statement inside its body, or the value returned from a 'return' form.","title":"Defenition"},{"location":"special_forms/#examples","text":"(prog (a b) (plus a b) ) this is a program that asks for 2 inputs, a and b , then returns their sum using the predefined function plus . (prog (a b) (minus a b) (plus a b) ) This code behaves the same as the previous one, since the last statment is the plus function.","title":"Examples"},{"location":"special_forms/#func","text":"( func Atom Params Body )","title":"func"},{"location":"special_forms/#defenition_1","text":"This special form introduces a new user-defined function. The Atom parameter becomes the name of the function. The Params paremeter should contain a number of atoms that represent the function parameters. The Body parameter of the form is considered as the body of the function, containing a list of elements, which represent the sequence of statements that are going to be evaluated. Returns: The evaluation of the last statement inside its body, or the value returned from a 'return' form.","title":"Defenition"},{"location":"special_forms/#examples_1","text":"( fun c sum 3 (a b c) (plus (plus a b) c) ) (prog () (sum 3 1 2 3 ) ) returns: 6 In this code we can see how we first define a new function called sum3 that takes 3 parameters, and returns the sum of them, then we call that function inside the prog form. Notice how the parameters are spread and not in a list when calling the sum3 function.","title":"Examples"},{"location":"special_forms/#quote","text":"(quo te Lis t ) or `List","title":"quote"},{"location":"special_forms/#defenition_2","text":"Any list is supposed to be a special form or starts with a predicate or user-defined function, expect if it was quoted, then it can contain other kinds of data. The main purpose of the quote form is to be able to create lists of numbers or other data, which can be manipulated using the lists predefined functions . To evaluate a quoted list, we can simply use the special form eval . The contents of the quoted list should fall under the main rule of lists. Returns: its argument without evaluating it. The meaning of the function is to prevent evaluating its argument.","title":"Defenition"},{"location":"special_forms/#examples_2","text":"(prog () (head '( 1 2 3 )) ) Returns: 1 (prog () ( ta il (quo te ( 1 2 3 ))) ) Returns: '(2 3) (or in other words, (quote (2 3)))","title":"Examples"},{"location":"special_forms/#setq","text":"(setq Atom Element)","title":"setq"},{"location":"special_forms/#defenition_3","text":"This special form assigns a new value to a variable, or defines the variable if it hasn't been defined before. The Atom parameter becomes the name of the variable. The Element paremeter gets evaluated, and the value it returns is assigned to the variable. Returns: null","title":"Defenition"},{"location":"special_forms/#examples_3","text":"(prog () (se t q x 5 ) (se t q x (plus 10 5 )) ) In this code first we define the variable x with the value 5, then we assign it a new value which is (plus 10 5) , which gets evaluated first and then assigned to x , which will finally hold the value of 15.","title":"Examples"},{"location":"special_forms/#cond","text":"(co n d Eleme nt Eleme nt [ Eleme nt ] )","title":"cond"},{"location":"special_forms/#defenition_4","text":"This special form represents the conditional statement in Dysfunctional Lisp. The first Element parameter represents the condition statement. After evaluation it should hold a boolean value. The second Element parameter which is going to be evaluated in case the condition statement returned true . The third Element parameter is an optional parameter which is going to be evaluated in case the condition statement returned false . Returns: The evaluation of the second element if the condition was true, or the evaluation of the third element if the condition was false, or null in the absence of the third element.","title":"Defenition"},{"location":"special_forms/#examples_4","text":"(prog ( fla g a b) (co n d (grea ter fla g 5 ) (plus a b) (mi nus a b)) ) This code requires 3 inputs, if the first input was greater than 5, then it returns a + b , otherwise it returns a - b .","title":"Examples"},{"location":"special_forms/#while","text":"(while Eleme nt Body)","title":"while"},{"location":"special_forms/#defenition_5","text":"This is the only form capable of looping (aside from recursion) in Dysfunctional Lisp. The Element parameter represents the condition in which the while form will keep looping as long as its evaluation is true . The Body parameter represents the body of the while form, which is a sequence of elements that are going to be evaluated in each repetetion. Returns: null","title":"Defenition"},{"location":"special_forms/#examples_5","text":"(prog () (se t q i 1 ) (se t q sum 0 ) (while (lesseq i 10 ) (se t q sum (plus sum i)) (se t q i (plus i 1 )) ) (re turn sum) ) Returns: 55 This is a simple code where we sum the numbers from 1 to 10.","title":"Examples"},{"location":"special_forms/#lambda","text":"(lambda Params Body)","title":"lambda"},{"location":"special_forms/#defenition_6","text":"This special form represents a lambda function, at current stage of Dysfunctional Lisp, lambda functions are only used as callback functions, as we will see in the examples. The Params parameter represents the parameters of the lambda function. The Body parameter is considered as the body of the lambda function, containing a list of elements, which represent the sequence of statements that are going to be evaluated. Returns: The evaluation of the last statement inside its body, or the value returned from a 'return' form.","title":"Defenition"},{"location":"special_forms/#examples_6","text":"( fun c map (ls t f ) (co n d (isemp t y ls t ) (re turn '())) (co ns ( f (head ls t )) (map ( ta il ls t ) f )) ) (prog () (se t q ls t '( 1 2 3 4 )) (map ls t (lambda (a) ( t imes a a))) ) Returns: '(1 4 9 16)","title":"Examples"},{"location":"special_forms/#return","text":"(re turn Eleme nt )","title":"return"},{"location":"special_forms/#defenition_7","text":"This special form makes sense within a form that defines a local context ( func , lambda or prog ). It evaluates its argument and interrupts the execution of the nearest enclosing form with the context. The Element parameter gets evaluated and returned. Returns: The Evaluation of its argument","title":"Defenition"},{"location":"special_forms/#examples_7","text":"(prog () (re turn 5 ) 10 ) Returns: 5","title":"Examples"},{"location":"special_forms/#break","text":"(break)","title":"break"},{"location":"special_forms/#defenition_8","text":"The special form makes sense within a while form. It unconditionally interrupts the execution of the nearest while form. Returns: null","title":"Defenition"},{"location":"special_forms/#examples_8","text":"(prog () (se t q i 0 ) (while true (co n d (grea tere q i 10 ) (break)) (se t q i (plus i 1 )) ) (re turn i) ) Returns: 10","title":"Examples"},{"location":"syntax/","text":"Syntax","title":"Syntax"},{"location":"syntax/#syntax","text":"","title":"Syntax"}]}